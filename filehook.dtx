% \iffalse meta-comment
%% Copyright (c) 2010 by Martin Scharrer <martin@scharrer-online.de>
%% -----------------------------------------------------------------
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3c
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%
%%   http://www.latex-project.org/lppl.txt
%%
%% and version 1.3c or later is part of all distributions of LaTeX
%% version 2008/05/04 or later.
%%
%% This work has the LPPL maintenance status `maintained'.
%%
%% The Current Maintainer of this work is Martin Scharrer.
%%
%% This work consists of the files filehook.dtx, filehook.ins
%% and the derived file filehook.sty.
%%
%% $Id: filehook.dtx 1939 2010-12-27 19:48:33Z martin $
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{filehook.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{filehook}
%<*package>
    [2010/12/20 v0.3 Hooks for input files]
%</package>
%
%<*driver>
\documentclass{ydoc}[2010/12/20]
\usepackage{filehook}[2010/12/08]
\usepackage{ifpdf}
\usepackage{hyperref}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\providecommand*\pkg{\texttt}
\listfiles
\begin{document}
  \DocInput{filehook.dtx}
  \PrintChanges
  \PrintIndex
\end{document}
%</driver>
% \fi
%
% \CheckSum{651}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2010/04/08}{Initial version}
% \changes{v0.2}{2010/12/08}{Added support for 'memoir' class and 'scrlfile' package. Remove support for deprecated 'fink' package.}
% \changes{v0.3}{2010/12/20}{Added hooks for package and class files. Changed a warning to an error and added the 'force' option to overwrite this.}
%
% \GetFileInfo{filehook.dtx}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \ifpdf
% \hypersetup{%
%   pdfauthor   = {Martin Scharrer <martin@scharrer-online.de>},
%   pdftitle    = {The filehook package},
%   pdfsubject  = {Documentation of LaTeX package 'filehook'},
%   pdfkeywords = {current filename, filename, file, name, LaTeX, TeX}
% }%
% \fi
% \clearpage
% \null
% \vspace*{-2em}
% \begin{center}
%   {\LARGE\sffamily The \emph{filehook} Package\\[\medskipamount]}
%   {\large Martin Scharrer \\[\medskipamount]\normalsize 
%   \url{martin@scharrer-online.de}\\[.8ex]
%   \url{http://www.ctan.org/pkg/filehook/}\\[\bigskipamount]}
%   {\large Version \fileversion\ -- \filedate}\\
% \end{center}
% \vspace{1.2em}%
%
% \begin{abstract}
% This small package provides hooks for input files. Document and package authors can use these hooks to
% execute code at begin or the end of specific or all input files.
% \end{abstract}
%
% \section{Introduction}
% These package changes some internal \LaTeX{} macros used to load input files so that they include `hooks'.
% A hook is an (internal) macro executed at specific points. Normally it is initially empty, but can be extended using
% an user level macro. The most common hook in \LaTeX{} is the `At-Begin-Document' hook. Code can be added to this hook
% using \Macro{AtBeginDocument}{<\TeX code>}.
%
% \section{Usage}
% This package provides several groups of hooks: for file read using \Macro{input}, for files read using \Macro{include} and for all read files (i.e.\ all files read using
% \Macro{InputIfFileExists}, which includes package and class files and files falling into the first two groups). Since v0.3 from 2010/12/20 there are also hooks for package and class files.
% All groups include a `AtBegin' and a `AtEnd' macro. The \Macro{include} group has also a `After' hook which
% it is executed \emph{after} the page break (\Macro{clearpage}) is inserted by the \Macro{include} code. In contrast, the `AtEnd' hook is executed before the trailing page break 
% and the `AtBegin' hook is executed after the \emph{leading} page break.
%
% The first three groups includes general and file specific hooks. The general hooks are executed for every file of this group and provide the file name as argument |#1|.
% The file specific ones are only executed for a certain file. The package and class hocks are always specific to one file.
%
% The below macros can be used to add material (\TeX{} code) to the related hooks. All `AtBegin' macros will \emph{append} the code to the hooks, but the
% `AtEnd' and `After' macros will \emph{prefix} the code instead. This ensures that two different packages adding material in `AtBegin'/`AtEnd' pairs do not
% overlap each other. Instead the later used package adds the code closer to the file content, `inside' the material added by the first package.
% Therefore it is safely possible to surround the content of a file with multiple \LaTeX{} environments using multiple `AtBegin'/`AtEnd' macro calls.
% If required inside another package a different order can be enforced by using the internal hook macros shown in the implementation section.
%
% \subsection*{Include Files}
% \DescribeMacro{\AtBeginOfIncludes}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfIncludes}{<\TeX\ code>}
% \DescribeMacro{\AfterIncludes}{<\TeX\ code>}
% All these macros take one argument (some \TeX{} code) which is added to the specific hook for files read using \Macro{include}.
% The code can use the macro argument |#1|
% which will be expanded to the include \meta{file name}, i.e.\ the hooks are macros with one argument which will be the file name.
% As described above the `AtEnd' hook is executed before and the `After' hook is executed after the trailing \Macro{clearpage}.
% Note that material which appears in the page header or footer should be updated in the `After' hook, not the `AtEnd` hook, to ensure
% that the old values are still valid for the last page.
%
% \DescribeMacro{\AtBeginOfIncludeFile}{<file name>}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfIncludeFile}{<file name>}{<\TeX\ code>}
% \DescribeMacro{\AfterIncludeFile}{<file name>}{<\TeX\ code>}
% These file-specific macros take the two arguments. The \meta{code} is only executed for the file with the given \meta{file name}
% and only if it is read using \Macro{include}. It is not allowed to use macro arguments inside the code.
% The \meta{file name} should be identical to the name used for \Macro{include} and not include the `|.tex|' extension.
%
% \subsection*{Input Files}
%
% \DescribeMacro{\AtBeginOfInputs}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfInputs}{<\TeX\ code>}
% Like the \Macro{...OfIncludes}{code} macros above, just for file read using \Macro{input}. Again, the macro argument |#1| can be used inside the \meta{code} and
% will be expanded to the \meta{file name}.
%
% \DescribeMacro{\AtBeginOfInputFile}{<file name>}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfInputFile}{<file name>}{<\TeX\ code>}
% Like the \Macro{...OfIncludeFile}{<file name>}{code} macros above, just for file read using \Macro{input}. Here the \meta{file name} should include the file
% extension! The \meta{code} must not include any macro arguments (|#1|).
%
% \subsection*{All Files}
%
% \DescribeMacro{\AtBeginOfFiles}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfFiles}{<\TeX\ code>}
% These macros add the given \marg{code} to two hooks executed for all files read using the \Macro{InputIfFileExists} macro. This macro is used internally by the 
% \Macro{input}, \Macro{include} and \Macro{usepackage}/\Macro{RequirePackage} macros. Packages and classes might use it to include additional or auxiliary files.
% Authors can exclude those files from the hooks by using \Macro{IfFileExists}{<file name>}|{\@input\@filef@und}{}| instead.
%
% \DescribeMacro{\AtBeginOfFile}{<file name with extension>}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfFile}{<file name with extension>}{<\TeX\ code>}
% Like the {\expandafter\Macro\csname...OfIncludeFile\endcsname{<file name>}{<\TeX\ code>}} macros above, just for `all' read files. Here the \meta{file name} should include the file
% extension! The \meta{code} must not include any macro arguments (|#1|).
%
% The `all files' hooks are closer to the file content than the \Macro{input} and \Macro{include} hook, i.e.\ the \Macro{AtBeginOfFiles} comes \emph{after} the \Macro{AtBeginOfIncludes} and
% the \Macro{AtEndOfFiles} comes \emph{before} the \Macro{AtEndOfIncludes} hook.
%
%
% \subsection*{Package Files}
%
% \DescribeMacro{\AtBeginOfPackageFile}{<package name>}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfPackageFile}*{<package name>}{<\TeX\ code>}
% This macros install the given \MacroArgs<\TeX\ code> in the `AtBegin' and `AtEnd' hooks of the given package file.
% The \Macro\AtBeginOfPackageFile simply executes \Macro\AtBeginOfFile{<package name>.sty}{<\TeX code>}.
% Special care is taken to ensure that the `AtEnd' code is executed \emph{after} any code installed by the package itself
% using the \LaTeX\ macro \Macro\AtEndOfPackage.
% If the starred version is used and the package is already loaded the code
% is executed right away.
%
%
% \subsection*{Class Files}
%
% \DescribeMacro{\AtBeginOfClassFile}{<class name>}{<\TeX\ code>}
% \DescribeMacro{\AtEndOfClassFile}*{<class name>}{<\TeX\ code>}
% This macros install the given \MacroArgs<\TeX\ code> in the `AtBegin' and `AtEnd' hooks of the given class file.
% They work with classes loaded using \Macro\LoadClass, \Macro\LoadClassWithOptions and also \Macro\documentclass.
% However, in the latter case |filehook| must be loaded using \Macro\RequirePackage beforehand.
% The \Macro\AtBeginOfClassFile simply executes \Macro\AtBeginOfFile{<class name>.cls}{<\TeX code>}.
% Special care is taken to ensure that the `AtEnd' code is executed \emph{after} any code installed by the class itself
% using the \LaTeX\ macro \Macro\AtEndOfClass.
% If the starred version is used and the class is already loaded the code
% is executed right away.
%
%
% \StopEventually{}
%
% \section{Compatibility Issues with other Packages}
% The |filehook| package might clash with other packages or classes which also redefine \Macro{InputIfFileExists}.
% Special compatibility code is in place for the known packages listed below (in their current implementation).
% If any other unknown definition is found an error will be raised. The package option `|force|' can be used
% to prevent this and to force the redefinition of this macro.
% Then any previous modifications will be lost, which will most likely break the other package.
% Please do not hesitate to inform the author of |filehook| of any encountered problems with other packages.
%
% \subsection*{jmlrbook}
% The |jmlrbook| class from the |jmlr| bundle temporary redefines \Macro{InputIfFileExists} to import papers.
% The `original' definition is saved away at load time of the package and is used internally by the new definition.
% This means that the hooks will not be active for this imported files because |filehook| is loaded after the class.
% This should not affect its normal usage.
% Note that, in theory, the package could be loaded before \Macro{documentclass} using \Macro{RequirePackage} to enable the file hooks also for these files.
%
% \subsection*{memoir}
% The |memoir| class redefines \Macro{InputIfFileExists} to add own hooks identical to the |At...OfFiles| hooks (there called \Macro{AtBeginFile} and \Macro{AtEndFile}).
% This hooks will be moved to the corresponding ones of |filehook| and will keep working as normal.
%
% \subsection*{scrlfile}
% The |scrlfile| package from the \emph{koma-script} bundle redefines \Macro{InputIfFileExists} to allow file name aliases and to also add hooks.
% If required it should be loaded before |filehook|, which will add its hooks correctly to the modified definition.
%
% \subsection*{fink}
% The |filehook| and |currfile| packages where written as replacements for the |fink| package, where |filehook| provides the necessary hooks for |currfile|.
% The |fink| package has now been deprecated in favour of |currfile| and should not be used anymore. The |fink| compatibility code has been removed from |filehook|
% and both cannot be used successfully together as both redefine the \Macro{InputIfFileExists} macro.
%
% \subsection*{listings}
% The \pkg{listings} package uses \Macro{input} inside \Macro{lstinputlisting}. Therefore the |InputFile|(|s|) and |File|(|s|) hooks are also triggered for these files.
% Please note that this hooks are executing inside a verbatim environment. While the code in the hook is not affected (because it was added outside the verbatim
% environment), any further code read using any input macro (\Macro{input}, \Macro{@input}, \Macro{@@input} (\TeX's \Macro{input}), \ldots) will be processed verbatim and typeset
% as part of the listing. A known package suffering from this is \pkg{svn-multi} which loads |.svx| files for every |.tex| file.
% A workaround for this issue is to temporally redefine \Macro{input} to \Macro{@input} for \Macro{lstinputlisting}: |{\let\input\@input\lstinputlisting{...}}|.
%
% 
% \section{Implementation}\label{sec:impl}
%
% \iffalse
%<*package>
% \fi
%
% \subsection{Options}
%    \begin{macrocode}
\newif\iffilehook@force
\DeclareOption{force}{\filehook@forcetrue}
\ProcessOptions\relax
%    \end{macrocode}
%
%
%
% \subsection{Initialisation of Hooks}
% The general hooks are initialised to call the file specific hooks.
%
% \begin{macro}{\filehook@include@atbegin}
% \begin{macro}{\filehook@include@atend}
% \begin{macro}{\filehook@include@after}
% Note: |#1| always includes the |.tex| extension.
%    \begin{macrocode}
\def\filehook@include@atbegin#1{%
  \let\InputIfFileExists\filehook@@InputIfFileExists
  \filehook@every@atbegin{#1}%
  \@nameuse{\filehook@include@atbegin@#1}%
}
\def\filehook@include@atend#1{%
  \@nameuse{\filehook@include@atend@#1}%
}
\def\filehook@include@after#1{%
  \@nameuse{\filehook@include@after@#1}%
  \filehook@every@atend{#1}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\filehook@input@atbegin}
% \begin{macro}{\filehook@input@atend}
%    \begin{macrocode}
\def\filehook@input@atbegin#1{%
  \let\InputIfFileExists\filehook@@InputIfFileExists
  \filehook@parsefile{#1}%
  \filehook@every@atbegin{#1}%
  \@nameuse{\filehook@input@atbegin@\filehook@filename}%
}
\def\filehook@input@atend#1{%
  \filehook@parsefile{#1}%
  \@nameuse{\filehook@input@atend@\filehook@filename}%
  \filehook@every@atend{#1}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\filehook@atbegin}
% \begin{macro}{\filehook@atend}
%    \begin{macrocode}
\def\filehook@atbegin#1{%
  \filehook@parsefile{#1}%
  \@nameuse{\filehook@atbegin@\filehook@filename}%
}
\def\filehook@atend#1{%
  \filehook@parsefile{#1}%
  \@nameuse{\filehook@atend@\filehook@filename}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\filehook@every@atbegin}
% \begin{macro}{\filehook@every@atend}
%    \begin{macrocode}
\def\filehook@every@atbegin#1{%
}
\def\filehook@every@atend#1{%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Hook Modification Macros}
% The following macros are used to modify the hooks, i.e.\ to prefix or append code to them.
%
% \subsubsection*{Internal Macros}
%
% The macro prefixes for the file specific hooks are stored in macros to reduce the number of 
% tokens in the following macro definitions.
%    \begin{macrocode}
\def\filehook@include@atbegin@{filehook@include@atbegin@}
\def\filehook@include@atend@{filehook@include@atend@}
\def\filehook@include@after@{filehook@include@after@}
\def\filehook@input@atbegin@{filehook@input@atbegin@}
\def\filehook@input@atend@{filehook@input@atend@}
\def\filehook@input@after@{filehook@input@after@}
\def\filehook@atbegin@{filehook@atbegin@}
\def\filehook@atend@{filehook@atend@}
\def\filehook@after@{filehook@after@}
%    \end{macrocode}
%
%
% \begin{macro}{\filehook@append}
% Uses default \LaTeX{} macro.
%    \begin{macrocode}
\def\filehook@append{\g@addto@macro}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\filehook@appendwarg}
% Appends code with one macro argument. The \Macro{@tempa} intermediate step is required because of the
% included |##1| which wouldn't correctly expand otherwise.
%    \begin{macrocode}
\long\def\filehook@appendwarg#1#2{%
  \begingroup
    \toks@\expandafter{#1{##1}#2}%
    \edef\@tempa{\the\toks@}%
    \expandafter\gdef\expandafter#1\expandafter##\expandafter1\expandafter{\@tempa}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\filehook@prefix}
% Prefixes code without an argument to a hook.
%    \begin{macrocode}
\long\def\filehook@prefix#1#2{%
  \begingroup
    \@temptokena{#2}%
    \toks@\expandafter{#1}%
    \xdef#1{\the\@temptokena\the\toks@}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\filehook@prefixwarg}
% Prefixes code with an argument to a hook.
%    \begin{macrocode}
\long\def\filehook@prefixwarg#1#2{%
  \begingroup
    \@temptokena{#2}%
    \toks@\expandafter{#1{##1}}%
    \edef\@tempa{\the\@temptokena\the\toks@}%
    \expandafter\gdef\expandafter#1\expandafter##\expandafter1\expandafter{\@tempa}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\filehook@parsefile}
% Parses filename using the \LaTeX\ macro and defines it with an extension added if required.
%    \begin{macrocode}
\def\filehook@parsefile#1{%
  \filename@parse{#1}%
  \edef\filehook@filename{\filename@area\filename@base.\ifx\filename@ext\relax tex\else\filename@ext\fi}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection*{User Level Macros}
% The user level macros simple use the above defined macros on the appropriate hook.
%
% \begin{macro}{\AtBeginOfIncludes}
%    \begin{macrocode}
\newcommand*\AtBeginOfIncludes{%
  \filehook@appendwarg\filehook@include@atbegin
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfIncludes}
%    \begin{macrocode}
\newcommand*\AtEndOfIncludes{%
  \filehook@prefixwarg\filehook@include@atend
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AfterOfIncludes}
%    \begin{macrocode}
\newcommand*\AfterIncludes{%
  \filehook@prefixwarg\filehook@include@after
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtBeginOfIncludeFile}
%    \begin{macrocode}
\newcommand*\AtBeginOfIncludeFile[1]{%
  \@ifundefined{\filehook@include@atbegin@#1.tex}%
    {\long\global\@namedef{\filehook@include@atbegin@#1.tex}}%
    {\expandafter\filehook@append\csname\filehook@include@atbegin@#1.tex\endcsname}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfIncludeFile}
%    \begin{macrocode}
\newcommand*\AtEndOfIncludeFile[1]{%
  \@ifundefined{\filehook@include@atend@#1.tex}%
    {\long\global\@namedef{\filehook@include@atend@#1.tex}}%
    {\expandafter\filehook@prefix\csname\filehook@include@atend@#1.tex\endcsname}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AfterOfIncludeFile}
%    \begin{macrocode}
\newcommand*\AfterOfIncludeFile[1]{%
  \@ifundefined{\filehook@include@after@#1.tex}%
    {\long\global\@namedef{\filehook@include@after@#1.tex}}%
    {\expandafter\filehook@prefix\csname\filehook@include@after@#1.tex\endcsname}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtBeginOfInputs}
%    \begin{macrocode}
\newcommand*\AtBeginOfInputs{%
  \filehook@appendwarg\filehook@input@atbegin
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfInputs}
%    \begin{macrocode}
\newcommand*\AtEndOfInputs{%
  \filehook@prefixwarg\filehook@input@atend
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtBeginOfInputFile}
%    \begin{macrocode}
\newcommand*\AtBeginOfInputFile[1]{%
  \filehook@parsefile{#1}%
  \@ifundefined{\filehook@input@atbegin@\filehook@filename}%
    {\long\global\@namedef{\filehook@input@atbegin@\filehook@filename}}%
    {\expandafter\filehook@append\csname\filehook@input@atbegin@\filehook@filename\endcsname}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfInputFile}
%    \begin{macrocode}
\newcommand*\AtEndOfInputFile[1]{%
  \filehook@parsefile{#1}%
  \@ifundefined{\filehook@input@atend@\filehook@filename}%
    {\long\global\@namedef{\filehook@input@atend@\filehook@filename}}%
    {\expandafter\filehook@prefix\csname\filehook@input@atend@\filehook@filename\endcsname}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtBeginOfFiles}
%    \begin{macrocode}
\newcommand*\AtBeginOfFiles{%
  \filehook@appendwarg\filehook@atbegin
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfFiles}
%    \begin{macrocode}
\newcommand*\AtEndOfFiles{%
  \filehook@prefixwarg\filehook@atend
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtBeginOfEveryFile}
%    \begin{macrocode}
\newcommand*\AtBeginOfEveryFile{%
  \filehook@appendwarg\filehook@every@atbegin
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfEveryFile}
%    \begin{macrocode}
\newcommand*\AtEndOfEveryFile{%
  \filehook@prefixwarg\filehook@every@atend
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtBeginOfFile}
%    \begin{macrocode}
\newcommand*\AtBeginOfFile[1]{%
  \filehook@parsefile{#1}%
  \@ifundefined{\filehook@atbegin@\filehook@filename}%
    {\long\global\@namedef{\filehook@atbegin@\filehook@filename}}%
    {\expandafter\filehook@append\csname\filehook@atbegin@\filehook@filename\endcsname}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfFile}
%    \begin{macrocode}
\newcommand*\AtEndOfFile[1]{%
  \filehook@parsefile{#1}%
  \@ifundefined{\filehook@atend@\filehook@filename}%
    {\long\global\@namedef{\filehook@atend@\filehook@filename}}%
    {\expandafter\filehook@prefix\csname\filehook@atend@\filehook@filename\endcsname}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\AtBeginOfPackageFile}[1]{package name}
% Simply add the package extension and calls the general macro.
%    \begin{macrocode}
\newcommand*\AtBeginOfPackageFile[1]{%
    \AtBeginOfFile{#1.\@pkgextension}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\AtEndOfPackageFile}
%    \begin{macrocode}
\newcommand*\AtEndOfPackageFile{%
    \@ifnextchar*\AtEndOfPackageFile@star\AtEndOfPackageFile@normal
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfPackageFile@star}[2]{package name}{code}
% If the package is already loaded the code is executed right away.
% Otherwise it is installed normally.
%    \begin{macrocode}
\def\AtEndOfPackageFile@star*#1#2{%
    \@ifpackageloaded{#1}%
        {#2}%
        {\AtEndOfPackageFile@normal{#1}{#2}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfPackageFile@normal}[2]{package name}{code}
% Installs the code at the end of the package file inside a \Macro\AtEndOfPackage
% command to ensure it is executed after any \Macro\AtEndOfPackage code installed
% by the package itself.
%
% Note if the package was already loaded or is not loaded at all the installed
% code is never executed.
%    \begin{macrocode}
\def\AtEndOfPackageFile@normal#1#2{%
    \AtEndOfFile{#1.\@pkgextension}{\AtEndOfPackage{#2}}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\AtBeginOfClassFile}[1]{class name}
% Simply add the class extension and calls the general macro.
%    \begin{macrocode}
\newcommand*\AtBeginOfClassFile[1]{%
    \AtBeginOfFile{#1.\@clsextension}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\AtEndOfClassFile}[2]{class name}{code}
%    \begin{macrocode}
\newcommand*\AtEndOfClassFile{%
    \@ifnextchar*\AtEndOfClassFile@star\AtEndOfClassFile@normal
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfClassFile@star}[2]{class name}{code}
% If the class is already loaded the code is executed right away.
% Otherwise it is installed normally.
%    \begin{macrocode}
\def\AtEndOfClassFile@star*#1#2{%
    \@ifclassloaded{#1}%
        {#2}%
        {\AtEndOfClassFile@normal{#1}{#2}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AtEndOfClassFile@normal}[2]{class name}{code}
% Installs the code at the end of the class file inside a \Macro\AtEndOfClass
% command to ensure it is executed after any \Macro\AtEndOfClass code installed
% by the class itself.
%
% Note if the class was already loaded or is not loaded at all the installed
% code is never executed.
%    \begin{macrocode}
\def\AtEndOfClassFile@normal#1#2{%
    \AtEndOfFile{#1.\@clsextension}{\AtEndOfClass{#2}}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Installation of Hooks}
% The \Macro{@input@} and \Macro{@iinput} macros from |latex.ltx| are redefined to install the hooks.
%
% First the original definitions are saved away.
%    \begin{macrocode}
\let\filehook@orig@@input@\@input@
\let\filehook@orig@@iinput\@iinput
%    \end{macrocode}
%
% \begin{macro}{\@input@}
% This macro is redefined for the \Macro{include} file hooks.
% Checks if the next command is \Macro{clearpage} which indicates that we are inside \Macro{@include}.
% If so the hooks are installed, otherwise the original macro is used unchanged.
% For the `after' hook an own \Macro{clearpage} is inserted and the original one is gobbled.
%
%    \begin{macrocode}
\def\@input@#1{%
  \@ifnextchar\clearpage
    {\filehook@include@atbegin{#1}%
     \filehook@orig@@input@{#1}%
     \filehook@include@atend{#1}%
     \clearpage
     \filehook@include@after{#1}%
     \@gobble
    }%
    {\filehook@orig@@input@{#1}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@iinput}
% This macro is redefined for the \Macro{input} file hooks.
% it simply surrounds the original macro with the hooks.
%    \begin{macrocode}
\def\filehook@@iinput#1{%
  \filehook@input@atbegin{#1}%
  \filehook@orig@@iinput{#1}%
  \filehook@input@atend{#1}%
}
\let\@iinput\filehook@@iinput
%    \end{macrocode}
% \end{macro}
%
% The |filehook| default definition of \Macro{InputIfFileExists} is defined here
% together with alternatives definitions for comparison.
% There are stored in a macro which is expanded if required.
% This is always done inside a group to keep them temporary only.
%    \begin{macrocode}
\def\filehook@alt@InputIfFileExists{%
%
\long\def\latex@InputIfFileExists##1##2{%
  \IfFileExists{##1}%
    {##2\@addtofilelist{##1}%
     \@@input\@filef@und
    }%
}
%
\long\gdef\filehook@default@InputIfFileExists##1##2{%
  \IfFileExists{##1}%
    {##2\@addtofilelist{##1}%
     \filehook@every@atbegin{##1}%
     \filehook@atbegin{##1}%
     \@@input\@filef@und
     \filehook@atend{##1}%
     \filehook@every@atend{##1}%
    }%
}
%
\long\gdef\filehook@@default@InputIfFileExists##1##2{%
  \let\InputIfFileExists\filehook@InputIfFileExists
  \IfFileExists{##1}%
    {##2\@addtofilelist{##1}%
     \filehook@atbegin{##1}%
     \@@input\@filef@und
     \filehook@atend{##1}%
    }%
}
%
\long\def\memoir@InputIfFileExists##1##2{%
  \IfFileExists{##1}%
    {##2\@addtofilelist{##1}\m@matbeginf{##1}%
     \@@input \@filef@und
     \m@matendf{##1}%
     \killm@matf{##1}}%
}
%
\long\def\scrlfile@InputIfFileExists##1##2{%
  \begingroup\expandafter\expandafter\expandafter\endgroup
  \expandafter\ifx\csname ##1-@alias\endcsname\relax
    \expandafter\@secondoftwo
  \else
    \scr@replacefile@msg{\csname ##1-@alias\endcsname}{##1}%
    \expandafter\@firstoftwo
  \fi
  {%
    \expandafter\InputIfFileExists\expandafter{\csname
      ##1-@alias\endcsname}{##2}%
  }%
  {\IfFileExists{##1}{%
      \scr@load@hook{before}{##1}%
      ##2\@addtofilelist{##1}%
      \@@input \@filef@und
      \scr@load@hook{after}{##1}%
    }}%
}
%
\long\def\filehook@scrlfile@InputIfFileExists##1##2{%
  \begingroup\expandafter\expandafter\expandafter\endgroup
  \expandafter\ifx\csname ##1-@alias\endcsname\relax
    \expandafter\@secondoftwo
  \else
    \scr@replacefile@msg{\csname ##1-@alias\endcsname}{##1}%
    \expandafter\@firstoftwo
  \fi
  {%
    \expandafter\InputIfFileExists\expandafter{\csname
      ##1-@alias\endcsname}{##2}%
  }%
  {\IfFileExists{##1}{%
      \scr@load@hook{before}{##1}%
      ##2\@addtofilelist{##1}%
      \filehook@every@atbegin{##1}%
      \filehook@atbegin{##1}%
      \@@input \@filef@und
      \filehook@atend{##1}%
      \filehook@every@atend{##1}%
      \scr@load@hook{after}{##1}%
    }}%
}
%
\long\def\filehook@@scrlfile@InputIfFileExists##1##2{%
  \let\InputIfFileExists\filehook@InputIfFileExists
  \begingroup\expandafter\expandafter\expandafter\endgroup
  \expandafter\ifx\csname ##1-@alias\endcsname\relax
    \expandafter\@secondoftwo
  \else
    \scr@replacefile@msg{\csname ##1-@alias\endcsname}{##1}%
    \expandafter\@firstoftwo
  \fi
  {%
    \expandafter\InputIfFileExists\expandafter{\csname
      ##1-@alias\endcsname}{##2}%
  }%
  {\IfFileExists{##1}{%
      \scr@load@hook{before}{##1}%
      ##2\@addtofilelist{##1}%
      \filehook@atbegin{##1}%
      \@@input \@filef@und
      \filehook@atend{##1}%
      \scr@load@hook{after}{##1}%
    }}%
}
%
}
\@onlypreamble\filehook@alt@InputIfFileExists
%    \end{macrocode}
%
% If the |scrlfile| package definition is detected the |filehook|s are added
% to that definition. Unfortunately the \Macro{scr@load@hook}{before} hook is placed \emph{before}
% not after the |#2\@addtofilelist{#1}| code. Otherwise the |filehook|s could simply be added to these hooks.
% Note that this will stop working if |scrlfile| ever changes its definition of the \Macro{InputIfFileExists} macro.
%    \begin{macrocode}
%
\def\filehook@if@scrlfile#1{%
  \@ifpackageloaded {scrlfile}{%
  \ifx\InputIfFileExists\scrlfile@InputIfFileExists
    \global\let\filehook@InputIfFileExists\filehook@scrlfile@InputIfFileExists
    \global\let\filehook@@InputIfFileExists\filehook@@scrlfile@InputIfFileExists
    \global\let\InputIfFileExists\filehook@InputIfFileExists
    \PackageInfo{filehook}{Package 'scrlfile' detected and compensated for}%
  \else
    \iffilehook@force
      \global\let\filehook@InputIfFileExists\filehook@default@InputIfFileExists
      \global\let\filehook@@InputIfFileExists\filehook@@default@InputIfFileExists
      \global\let\InputIfFileExists\filehook@InputIfFileExists
      \PackageWarning{filehook}{Detected 'scrlfile' package with unknown definition of \string\InputIfFileExists.^^J%
                                The 'force' option of 'filehook' is in effect. Macro is overwritten with default!}%
    \else
      \PackageError{filehook}{Detected 'scrlfile' package with unknown definition of \string\InputIfFileExists.^^J%
                              Use the 'force' option of 'filehook' to overwrite it.}%
    \fi
  \fi
  #1}%
}
\@onlypreamble\filehook@if@scrlfile
%
\def\filehook@if@memoir#1{%
  \@ifclassloaded {memoir}{%
  \ifx\InputIfFileExists\memoir@InputIfFileExists
    \global\let\filehook@InputIfFileExists\filehook@default@InputIfFileExists
    \global\let\filehook@@InputIfFileExists\filehook@@default@InputIfFileExists
    \global\let\InputIfFileExists\filehook@InputIfFileExists
    \AtBeginOfFiles{\m@matbeginf{#1}}%
    \AtEndOfFiles{\m@matendf{#1}\killm@matf{#1}}%
    \PackageInfo{filehook}{Detected 'memoir' class: the memoir hooks will be moved to the 'At...OfFiles' hooks}
  \else
    \iffilehook@force
      \global\let\filehook@InputIfFileExists\filehook@default@InputIfFileExists
      \global\let\filehook@@InputIfFileExists\filehook@@default@InputIfFileExists
      \PackageWarning{filehook}{Detected 'memoir' class with unknown definition of \string\InputIfFileExists.^^J%
                                The 'force' option of 'filehook' is in effect. Macro is overwritten with default!}%
    \else
      \PackageError{filehook}{Detected 'memoir' class with unknown definition of \string\InputIfFileExists.^^J%
                              Use the 'force' option of 'filehook' to overwrite it.}%
    \fi
  \fi
  #1}%
}
\@onlypreamble\filehook@if@memoir
%    \end{macrocode}
%
% The default and alternative definitions of \Macro\InputIfFileExists are first expanded inside a group.
%    \begin{macrocode}
\begingroup
\filehook@alt@InputIfFileExists
%    \end{macrocode}
% First we test for the |scrlfile| package. The test macro adds the necessary patches if so.
% In order to also support it when it is loaded afterwards the two hooks below are used to revert the definition
% before the package and patch it afterwards.
%    \begin{macrocode}
\filehook@if@scrlfile{}{%
  \AtBeginOfPackageFile{scrlfile}{%
    {\filehook@alt@InputIfFileExists
     \global\let\InputIfFileExists\latex@InputIfFileExists
    }%
  }%
  \AtEndOfPackageFile{scrlfile}{%
    {\filehook@alt@InputIfFileExists
    \filehook@if@scrlfile{}{}}%
  }%
%    \end{macrocode}
% If |memoir| is detected its hooks
% are added to the appropriate |At...OfFiles| hooks. This works fine because its hooks have the
% exact same position. Please note that the case when |memoir| is used together with |scrlfile| is not explicitly covered.
% In this case the |scrlfile| package will overwrite |memoir|s definition.
%    \begin{macrocode}
  \filehook@if@memoir{}{%
    \ifx\documentclass\@twoclasseserror\else
      \AtBeginOfClassFile{memoir}{%
        {\filehook@alt@InputIfFileExists
         \global\let\filehook@@InputIfFileExists\latex@InputIfFileExists
         \global\let\InputIfFileExists\latex@InputIfFileExists
         \global\let\@iinput\filehook@orig@@iinput
        }%
      }%
      \AtEndOfClassFile{memoir}{%
        \global\let\@iinput\filehook@@iinput
        {\filehook@alt@InputIfFileExists
        \filehook@if@memoir{}{}}%
      }%
    \fi
%    \end{macrocode}
% Finally, if no specific alternate definition is detected the original \LaTeX\ definition is checked for and a
% error is given if any other unknown definition is detected.
% The \opt{force} option will change the error into a warning and overwrite the macro with the default.
%    \begin{macrocode}
    \ifx\InputIfFileExists\latex@InputIfFileExists
      \global\let\filehook@InputIfFileExists\filehook@default@InputIfFileExists
      \global\let\filehook@@InputIfFileExists\filehook@@default@InputIfFileExists
    \else
      \iffilehook@force
        \global\let\filehook@InputIfFileExists\filehook@default@InputIfFileExists
        \global\let\filehook@@InputIfFileExists\filehook@@default@InputIfFileExists
        \PackageWarning{filehook}{Detected unknown definition of \string\InputIfFileExists.^^J%
                                  The 'force' option of 'filehook' is in effect. Macro is overwritten with default!}%
      \else
        \PackageError{filehook}{Detected unknown definition of \string\InputIfFileExists.^^J%
                                Use the 'force' option of 'filehook' to overwrite it.}%
      \fi
    \fi
}}
\endgroup
%    \end{macrocode}
%    \begin{macrocode}
\let\InputIfFileExists\filehook@InputIfFileExists
\AtBeginDocument{%
    \ifx\InputIfFileExists\filehook@InputIfFileExists\else
        \PackageWarning{filehook}{Macro \string\InputIfFileExists\space got redefined after 'filehook' was loaded.^^J%
                                  Certain file hooks might now be dysfunctional!}
    \fi
}
%    \end{macrocode}
%
% \iffalse
%</package>
% \fi
% \Finale
\endinput
